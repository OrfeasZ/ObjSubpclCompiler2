%{
	#include <Parser/Parser.h>

	extern int yylex();
	extern void yyerror(const char* err);
%}

%token AND ARRAY BEGINT DIV DO ELSE END IF INTEGER MOD NOT OF OR PROCEDURE PROGRAM REAL
%token RETURN THEN VAR WHILE LPAREN RPAREN STAR PLUS COMMA MINUS DOT SLASH COLON ASSIGN
%token SEMICOLON LT LTE NOTEQUAL EQUAL GT GTE LBRACK RBRACK
%token CLASS EXTENDS CONSTRUCTOR ABSTRACT
%token <string> UNSIGNED_INTEGER
%token <string> IDENTIFIER

%union {
	std::string* string;
}

%left OR
%left AND
%left PLUS MINUS
%left STAR SLASH
%left DIV MOD
%right NOT
%right THEN ELSE
%nonassoc GT LT GTE LTE EQUAL NOTEQUAL 
%nonassoc UMINUS UPLUS

%start file

%%

file
	: program
	;

program
	: PROGRAM id SEMICOLON body DOT
	;

body 
	: local_seq class_seq block
	| local_seq block
	| class_seq block
	| class_seq 
	| block
	;

procedure_body
	: local_seq block
	| block
	;

local_seq
	: local
	| local_seq local
	;

local
	: VAR id_decl
	| procedure
	;

procedure_seq
	: procedure
	| procedure_seq procedure
	;

procedure
	: header SEMICOLON procedure_body SEMICOLON
	;
	
procedure_body
	: VAR id_decl block
	| block
	;

id_decl
	: id_seq COLON type SEMICOLON
	| id_decl id_seq COLON type SEMICOLON
	;

header
	: PROCEDURE id LPAREN formal_seq RPAREN
	| PROCEDURE id LPAREN RPAREN
	;

formal_seq
	: formal
	| formal_seq SEMICOLON formal
	;

formal
	: VAR id_seq COLON type
	| id_seq COLON type
	;

id_seq
	: id 
	| id_seq COMMA id
	;

type
	: INTEGER
	| REAL
	| ARRAY LBRACK integer_const RBRACK OF type
	| class_type
	;

block
	: BEGINT stmt_seq END
	;

stmt_seq
	: stmt
	| stmt_seq SEMICOLON stmt
	;

stmt
	: 
	| l_value ASSIGN expr
	| block
	| call
	| IF expr THEN stmt ELSE stmt
	| IF expr THEN stmt
	| WHILE expr DO stmt
	| id COLON stmt
	| RETURN
	;

expr
	: l_value
	| r_value
	;

l_value
	: id
	| id DOT id
	| l_value LBRACK expr RBRACK
	| LPAREN l_value RPAREN
	;

r_value
	: integer_const
	| real_const
	| LPAREN r_value RPAREN
	| call
	| unop
	| binop
	;

call
	: id LPAREN RPAREN
	| id LPAREN expr_seq RPAREN
	| id DOT id LPAREN RPAREN
	| id DOT id LPAREN expr_seq RPAREN
	;

expr_seq
	: expr
	| expr_seq COMMA expr
	;

unop
	: NOT expr
	| UPLUS expr
	| UMINUS expr
	;

binop
	: expr PLUS expr
	| expr MINUS expr
	| expr STAR expr
	| expr SLASH expr
	| expr DIV expr
	| expr MOD expr
	| expr OR expr
	| expr AND expr
	| expr EQUAL expr
	| expr NOTEQUAL expr
	| expr LT expr
	| expr LTE expr
	| expr GT expr
	| expr GTE expr
	;

id 
	: IDENTIFIER { /*$$ = new Identifier(*$1); delete $1;*/ }
	;

integer_const
	: UNSIGNED_INTEGER { /*$$ = new Integer(*$1); delete $1;*/ }
	;

real_const
	: UNSIGNED_INTEGER DOT UNSIGNED_INTEGER { /*$$ = new Real(*$1, *$3); delete $1; delete $3;*/ }
	;

/* Class additions */

class_procedure_seq
	: class_procedure
	| class_procedure_seq class_procedure
	;

class_procedure
	: procedure
	| abstract_procedure
	;

abstract_procedure
	: ABSTRACT header SEMICOLON

class_seq
	: class_def
	| class_seq class_def
	;

class_def
	: class_header VAR id_decl class_body SEMICOLON
	| class_header class_body SEMICOLON
	;

class_header
	: CLASS id 
	| CLASS id EXTENDS id
	;

class_body
	: BEGINT class_constructor class_procedure_seq END
	| BEGINT class_constructor END
	;

class_constructor
	: class_constructor_header SEMICOLON procedure_body SEMICOLON
	;

class_constructor_header
	: PROCEDURE CONSTRUCTOR LPAREN formal_seq RPAREN
	| PROCEDURE CONSTRUCTOR LPAREN RPAREN
	;

class_type
	: id LPAREN RPAREN
	| id LPAREN expr_seq RPAREN
	;